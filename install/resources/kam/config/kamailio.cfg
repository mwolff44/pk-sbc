#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v4.4 - PyFreeBilling v2.0
# v1.21
#

#!define WITH_POSTGRES
#!define WITH_AUTH
#!define WITH_IPAUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
# #!define WITH_NATSIPPING
#!define WITH_ALIASDB
#!define WITH_SIPTRACE
#!define WITH_ENUM
#!define WITH_PYFB
##!define WITH_DEBUG


#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif


# *** SIP HEADERS

server_signature = no
server_header = "Server: PYFB"
user_agent_header = "X-PROXY: PyFB"
sip_warning = 0

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# *** Value defines - IDs used later in config
#!ifdef WITH_POSTGRES
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.

#!ifndef DBURL
#!define DBURL "postgres://kamailiopyfb:csips2016@192.168.40.50:5432/kamailiopyfb"
#!endif

#!ifndef DBPYFBURL
#!define DBPYFBURL "postgres://pyfreebilling:cSIPs!2016@192.168.40.50:5432/pyfreebilling"
#!endif

#!endif

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

####### Defined Values #########
# *** Value defines - IDs used later in config

# - flags
#       FLT_ - per transaction (message) flags
#       FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define TRUSTED_ADR_GR_CUST 1
# http://kamailio.org/docs/modules/4.4.x/modules/permissions.html#sec-registration-permissions
#!define TRUSTED_ADR_GR_REG_CUST 2 # filtered to be implemented
#!define TRUSTED_ADR_GR_GW 10
#!define GROUP_GL_NORM_RULE 0
#!define GROUP_SOFIA_INT 1
#!define GROUP_SOFIA_EXT 2

flags
   FLAG_FROM_FS: 9,
   FLAG_FROM_CUST: 10,
   FLAG_FROM_PROV: 11,
   FLAG_TRUSTED_SOURCE: 12;

####### Global Parameters #########
################################################################################
## LOGGING
################################################################################

#!ifdef WITH_DEBUG
    debug=4
    log_stderror=yes
#!else
    debug=2
    log_stderror=no
#!endif

memdbg=5
memlog=5

log_name="kamailio"
log_facility=LOG_LOCAL0

# number of SIP routing processes
children=8

port=5060

#!ifdef WITH_TLS
    enable_tls=yes
#!endif

# life time of TCP connection when there is no traffic
# - a bit higher than registration expires to cope with UA behind NAT
tcp_connection_lifetime=3605

####### Binding Parameters #########
#!ifndef tos
    tos=0x68
#!endif

####### Modules Section ########

# set paths to location of modules (to sources or installation folders)
#!ifdef WITH_SRCPATH
    mpath="modules/"
#!else
    mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"
#!endif

#!ifdef WITH_POSTGRES
    loadmodule "db_postgres.so"
#!endif

loadmodule "mi_fifo.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "mi_rpc.so"
loadmodule "acc.so"
loadmodule "avpops.so"
loadmodule "dispatcher.so"
loadmodule "dialplan.so"

#!ifdef WITH_AUTH
    loadmodule "auth.so"
    loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
    loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
    loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
    loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
    loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
    loadmodule "presence.so"
    loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
    loadmodule "nathelper.so"
    loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_TLS
    loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
    loadmodule "htable.so"
    loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
    loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
    loadmodule "debugger.so"
#!endif

#!ifdef WITH_SIPTRACE
    loadmodule "siptrace.so"
#!endif

#!ifdef WITH_PYFB
    loadmodule "uac.so"
#loadmodule "uac_redirect.so"
#!endif


# ----------------- setting module-specific parameters ---------------


# ----- mi_fifo params -----
modparam("mi_fifo", "fifo_name", "/var/run/kamailio/kamailio_fifo")

# ----- ctl params -----
#modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params -----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 30000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)


# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 1)
# do not append from tag to the RR (no need for this script)
#!ifdef WITH_PYFB
modparam("rr", "append_fromtag", 1)
#!else
modparam("rr", "append_fromtag", 0)
#!endif

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 1)
# max value for expires of registrations
modparam("registrar", "max_expires", 3600)
# set it to 1 to enable GRUU
modparam("registrar", "gruu_enabled", 0)


# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure the enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
        "src_user=$fU;src_domain=$fd;src_ip=$si;"
        "dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif


# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "timer_interval", 20)
modparam("usrloc", "timer_procs", 1)
#!endif


# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)

modparam("auth", "one_time_nonce", 1)
modparam("auth", "nonce_count", 1)
modparam("auth", "qop", "auth")
modparam("auth", "nonce_expire", 60)
modparam("auth", "nonce_auth_max_drift", 2)
modparam("auth", "auth_checks_register", 11)
modparam("auth", "auth_checks_no_dlg", 9)
modparam("auth", "auth_checks_in_dlg", 15)

#!ifdef WITH_PYFB
modparam("auth_db", "user_column", "username")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "db_url", DBPYFBURL)
modparam("auth_db", "version_table", 0)
#!else
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "password_column", "password")
#!endif

# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBPYFBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(s:sipacid)")
#!endif

#!endif


# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBPYFBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif


# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif


# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBPYFBURL)
# register callback to match myself condition with domains list
modparam("domain", "register_myself", 1)
#!endif


#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif


#!ifdef WITH_NAT
# ----- rtpproxy params -----
modparam("rtpproxy", "rtpproxy_sock", "")
#modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif


#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_SIPTRACE
# ----- siptrace params -----
modparam("siptrace", "duplicate_uri", SIPCAPTURL)
modparam("siptrace", "hep_mode_on", 1)
modparam("siptrace", "trace_to_database", 0)
modparam("siptrace", "trace_flag", 2)
modparam("siptrace", "hep_version", 1)
modparam("siptrace", "trace_on", SIPCAPT)
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 1)
modparam("debugger", "log_level_name", "exec")
#!endif

# ----- avpops params -----
modparam("avpops", "db_url", DBPYFBURL)
modparam("avpops", "avp_table", "usr_preferences")

# ----- dispatcher params -----
# modparam("dispatcher", "db_url", DBPYFBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_ping_from", "sip:sipcheck@MY_IP_ADDRESS")
modparam("dispatcher", "ds_ping_method", "INFO")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_probing_threshold", 3)
#configure codes or classes of SIP replies to list only allowed replies (i.e. when temporarily unavailable=480)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=480;code=404")

# ----- diaplan params -----
modparam("dialplan", "db_url", DBPYFBURL)
modparam("dialplan", "attrs_pvar", "$avp(s:dest)")


####### Routing Logic ########
# Mmodparam("dispatcher", "db_url",ain SIP request routing logic
# - processing of any incoming SIP request starts with this route
# - note: this is the same as route { ... }
request_route {

    # log the basic info regarding this call
    xlog("L_INFO", "$ci|start|----------------------------\n");
    xlog("L_INFO", "$ci|start|received $pr request $rm $ou\n");
    xlog("L_INFO", "$ci|log|source $si:$sp\n");
    xlog("L_INFO", "$ci|log|from $fu\n");
    xlog("L_INFO", "$ci|log|to $tu\n");

    # siptrace
    #!ifdef WITH_SIPTRACE
      sip_trace();
      setflag(22);
    #!endif

        # per request initial checks
        route(REQINIT);

        # NAT detection
        route(NATDETECT);

    # OPTION processing
    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
                sl_send_reply("200","Keepalive");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }

    # handle requests within SIP dialogs
        route(WITHINDLG);

        ### only initial requests (no To tag)

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans()) {
                        route(RELAY);
                }
                exit;
        }

        # handle retransmissions
        if(t_precheck_trans()) {
                t_check_trans();
                exit;
        }
        t_check_trans();

        # authentication
        route(AUTH);

        # record routing for dialog forming requests (in case they are routed)
        # - remove preloaded route headers
        remove_hf("Route");
        if (is_method("INVITE|SUBSCRIBE")) {
                record_route();
        }

        # account only INVITEs
        if (is_method("INVITE")) {
                setflag(FLT_ACC); # do accounting
        }

        # dispatch requests to foreign domains
        #route(SIPOUT);

        ### requests for my local domains

        # handle presence related requests
        #route(PRESENCE);

        # handle registrations
    if (is_method("REGISTER")) {
            route(REGISTRAR);
    }

        if ($rU==$null) {
                # request with no Username in RURI
        xlog("L_INFO", "$ci|stop|-------SIP 484---------------\n");
                sl_send_reply("484","Address Incomplete");
                exit;
        }

    # save callee ID
    $avp(callee) = $rU;
    route(FSDISPATCH);

    route(RELAY);
}

# Wrapper for relaying requests
route[RELAY] {

  xlog("L_INFO", "$ci|log|--RELAY--\n");
        # enable additional event routes for forwarded requests
        # - serial forking, RTP relaying handling, a.s.o.
        if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
        }
        if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
                if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
        }
        if (is_method("INVITE")) {
                if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
        }

        if (!t_relay()) {
    xlog("L_INFO", "$ci|end|unable to relay message\n");
                sl_reply_error();
        } else {
    xlog("L_INFO", "$ci|pass|successfull relay $du\n");
  }
  xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
}

# Per SIP request initial checks
route[REQINIT] {
    xlog("L_INFO", "$ci|log|--REQINIT--\n");
#!ifdef WITH_ANTIFLOOD
    xlog("L_INFO", "$ci|log|Antiflood protection\n");
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
        if(src_ip!=myself) {
                if($sht(ipban=>$si)!=$null) {
                        # ip is already blocked
                        xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
                        exit;
                }
                if (!pike_check_req()) {
                        xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
                        $sht(ipban=>$si) = 1;
            xlog("L_INFO", "$ci|stop|----------------------------\n");
                        exit;
                }
        }
        if($ua =~ "friendly-scanner|sipcli|sundayddr") {
        xlog("L_WARN", "$ci|end|dropping message with user-agent $ua from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }
    xlog("L_INFO", "$ci|log|OK -> continue\n");
#!endif

    if (is_method("INVITE|REGISTER")) {
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_WARN", "$ci|end|Someone from $si is doing an sql injection attack, blocking!\n");
            xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
        }
    }

    # initial sanity checks -- messages with
    # max_forwards==0, or excessively long requests
        if (!maxfwd_process("50") && $retcode==-1) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
                sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }
    # next hop is a gateway, so make no sense to
    # forward if MF is 0 (after decrement)
    if ( is_maxfwd_lt("5") ) {
        xlog("L_WARN", "$ci|end|too much hops from $si:$sp\n");
            sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
            exit;
    };

        /*if(is_method("OPTIONS") && uri==myself && $rU==$null) {
                sl_send_reply("200","Keepalive");
    xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }*/

        if(!sanity_check("1511", "7")) {
                xlog("L_WARN", "$ci|end|Malformed SIP message from $si:$sp\n");
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    xlog("L_INFO", "$ci|log|--WITHINDLG--\n");
    if (!has_totag()) {
        xlog("L_INFO", "$ci|log| return\n");
        return;
    }

        # sequential request withing a dialog should
        # take the path determined by record-routing
        if (loose_route()) {
        xlog("L_INFO", "$ci|log|loose route TRUE\n");
                route(DLGURI);
                if (is_method("BYE")) {
            xlog("L_INFO", "$ci|log|Method BYE - set acc flag\n");
                        setflag(FLT_ACC); # do accounting ...
                        setflag(FLT_ACCFAILED); # ... even if the transaction fails
                } else if ( is_method("ACK") ) {
                        # ACK is forwarded statelessy
            xlog("L_INFO", "$ci|log|Method ACK\n");
                        route(NATMANAGE);
                } else if ( is_method("NOTIFY") ) {
            xlog("L_INFO", "$ci|log|Method NOTIFY\n");
                        # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
                        record_route();
                }
        xlog("L_INFO", "$ci|log|Message has tag - no loose route -> relay\n");
                route(RELAY);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }

        if (is_method("SUBSCRIBE") && uri == myself) {
                # in-dialog subscribe requests
                route(PRESENCE);
        xlog("L_INFO", "$ci|stop|----------------------------\n");
                exit;
        }
        if ( is_method("ACK") ) {
                if ( t_check_trans() ) {
                    # no loose-route, but stateful ACK;
                    # must be an ACK after a 487
                    # or e.g. 404 from upstream server
                    route(RELAY);
            xlog("L_INFO", "$ci|stop|----------------------------\n");
                    exit;
                } else {
                        # ACK without matching transaction ... ignore and discard
            xlog("L_INFO", "$ci|stop|----------------------------\n");
                        exit;
                }
        }

    if ( is_method("INVITE") ) {
        sl_send_reply("100","Your Re-INVITE is received");
        if (!t_relay()) {
            sl_reply_error();
            break;
        }
        # sl_send_reply("200","OK");
        exit;
    }


    xlog("L_INFO", "$ci|stop|----------------------------\n");
        sl_send_reply("404","Not here");
        exit;
}

# Handle SIP registrations
route[REGISTRAR] {
  xlog("L_INFO", "$ci|log|--REGISTRAR--\n");
        if (!is_method("REGISTER")) {
    xlog("L_INFO", "$ci|log|Not a REGISTER method\n");
    xlog("L_INFO", "$ci|log| return\n");
    return;
  }

        if(isflagset(FLT_NATS)) {
                setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
                # do SIP NAT pinging
                setbflag(FLB_NATSIPPING);
#!endif
        }
  xlog("L_INFO", "$ci|log|Save user in location DB\n");
        if (!save("location")) {
                sl_reply_error();
        }
  xlog("L_INFO", "$ci|stop|----------------------------\n");
        exit;
}

# User speeddial
#!ifdef WITH_SPEEDDIAL
route[SPEEDDIAL] {
xlog("L_INFO", "$ci|log|--SPEEDDIAL--\n");
        # search for short dialing - 2-digit extension
        if($rU=~"^[0-9][0-9]$") {
                if(sd_lookup("speed_dial")) {
      xlog("L_INFO", "$ci|log| SPEED DIAL found \n");
      append_hf("P-hint: outbound speeddial\r\n");
                        route(SIPOUT);
                }
    else {
      xlog("L_INFO", "$ci|log| No SPEED DIAL found \n");
    }
        }
}
#!endif

# User location service
route[LOCATION] {
xlog("L_INFO", "$ci|log|--LOCATION--\n");
$var(DID) = $rU;

#!ifdef WITH_ALIASDB
    # search in DB-based aliases
    xlog("L_INFO", "$ci|log|Check if DestNum is DID list \n");
    if(alias_db_lookup("dbaliases")) {
        xlog("L_INFO", "$ci|log|DID found in dbaliases.  R-URI=$ru\n");
        $avp(s:dest)="DID";
        append_hf("P-hint: DID routing\r\n");
    }
    else  {
        xlog("L_INFO", "$ci|log|R-URI=$ru  DID Not found in dbaliases\n");
        return;
    }
#!endif
    xlog("L_INFO", "$ci|log|Check if corresponding user is registred\n");
    if (!lookup("location")) {
        $var(rc) = $rc;
        #route(TOVOICEMAIL);
        t_newtran();
        switch ($var(rc)) {
        case -1:
            xlog("L_INFO","$ci|log|R-URI=$ru - no contact found in location DB - continue \n");
            send_reply("480", "Temporarily Unavailable");
        case -3:
            xlog("L_INFO","$ci|log|R-URI=$ru - internal error when searching in location DB - 404 \n");
            send_reply("404", "Not Found");
            exit;
        case -2:
            xlog("L_INFO","$ci|log|R-URI=$ru - contacts found, but method not support in location DB - 405 \n");
            send_reply("405", "Method Not Allowed");
            exit;
        }
    } else {
    # User is registered. Overwrite the username part of the R-URI with the DID
    $rU = $var(DID);

    if($hdr(X-PyFB-CallType) == "DIDIN" || $hdr(X-PyFB-CallType) == "DIDOUT") {
        # Numbers normalization
        $var(sipaccount) = $hdr(X-PyFB-SIPAccountId);
        xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
        # Callee normalization
        if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcalleein)")) {
          xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcalleein)\n");
          xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
          if (!dp_translate("$avp(s:grpnormcalleein)", "$rU/$rU")) {
            xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
          }
          xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
        } else {
          xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
        }

        # Caller normalization
        if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallerin)")) {
          xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcallerin)\n");
          xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
          if (!dp_translate("$avp(s:grpnormcallerin)", "$fU/$avp(s:callernum)")) {
              xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
          } else {
              uac_replace_from("$avp(s:callernum)", "sip:$avp(s:callernum)@$fd");
              remove_hf("P-Asserted-Identity");
              append_hf("P-Asserted-Identity: <sip:$avp(s:callernum)@$fd>\r\n");
          }
          xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
        } else {
          xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
        }
    }

    append_hf("X-PyFB-DestDIDNum: $var(DID)\r\n");
    xlog("L_INFO","$ci|log|R-URI=$ru  Location=$du - contact found in location DB - route to user \n");
    xlog("L_INFO","$ci|log| return \n");
    return;
  }

        # when routing via usrloc, log the missed calls also
        if (is_method("INVITE")) {
                setflag(FLT_ACCMISSED);
        }

  # via FS
  #route(RELAY);
        #exit;
}

# Presence server processing
route[PRESENCE] {
  xlog("L_INFO", "$ci|log|--PRESENCE--\n");
        if(!is_method("PUBLISH|SUBSCRIBE")) return;

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                # returns here if no voicemail server is configured
                sl_send_reply("404", "No voicemail service");
                exit;
        }

#!ifdef WITH_PRESENCE
        if (!t_newtran()) {
                sl_reply_error();
                exit;
        }

        if(is_method("PUBLISH")) {
                handle_publish();
                t_release();
        } else if(is_method("SUBSCRIBE")) {
                handle_subscribe();
                t_release();
        }
        exit;
#!endif

        # if presence enabled, this part will not be executed
        if (is_method("PUBLISH") || $rU==$null) {
    xlog("L_INFO", "$ci|stop|----------------------------\n");
                sl_send_reply("404", "Not here");
                exit;
        }
  xlog("L_INFO", "$ci|log| return \n");
        return;
}

# IP authorization and user authentication
route[AUTH] {
  xlog("L_INFO", "$ci|log|--AUTH-\n");
  xlog("L_INFO", "$ci|log|Starting auth process ...\n");
#!ifdef WITH_AUTH

#!ifdef WITH_PYFB
        # do not auth traffic from PyFB B2BUA - trusted!
  xlog("L_INFO", "$ci|log|Is the message coming from FS ?\n");
        if(route(FSINBOUND)){
    xlog("L_INFO", "$ci|log| return \n");
    return;
  }
#!endif

#!ifdef WITH_IPAUTH
  xlog("L_INFO", "$ci|log|IP Auth process ...\n");
        if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_CUST)) {
    setflag(FLAG_FROM_CUST);
    $var(sipaccount) = $avp(s:sipacid);
    append_hf("X-PyFB-AccountId: $avp(s:sipacid)\r\n");
                xlog("L_INFO", "$ci|log|Call from customer : Source IP allowed - sipaccount : $avp(s:sipacid)\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
                return;
        }
  if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_GW)) {
    setflag(FLAG_FROM_PROV);
                xlog("L_INFO", "$ci|log|Call from provider GW : Source IP allowed\n"); # source IP allowed
    xlog("L_INFO", "$ci|log| return \n");
                return;
        }
  xlog("L_INFO", "$ci|log|Source IP not allowed ... or REGISTER message\n");
#!endif

        if (is_method("REGISTER") || uri==myself) {
                # authenticate requests
                if (!auth_check("$fd", "subscriber", "0")) {
      xlog("L_INFO", "$ci|log|Send auth challenge\n");
                        auth_challenge("$fd", "0");
      xlog("L_INFO", "$ci|stop|----------------------------\n");
                        exit;
                }
    setflag(FLAG_FROM_CUST);
    xlog("L_INFO", "$ci|log|User authenticated\n");
                # user authenticated - remove auth header
                if(!is_method("REGISTER|PUBLISH")){
      xlog("L_INFO", "$ci|log|User authenticated - not method REGISTER|PUBLISH\n");
      xlog("L_INFO", "$ci|log|User authenticated - remove auth header\n");
      xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
      $var(sipaccount) = $au;
      append_hf("X-PyFB-AccountId: $au\r\n");
                        consume_credentials();
    }
        }
        # if caller is not local subscriber, then check if it calls
        # a local destination, otherwise deny, not an open relay here
        if (from_uri!=myself && uri!=myself) {
    xlog("L_INFO", "$ci|log|Message for another relay -> not allowed - END 403\n");
    xlog("L_INFO", "$ci|stop|----------------------------\n");
                sl_send_reply("403","Not relaying");
                exit;
        }

#!endif
    xlog("L_INFO", "$ci|log| return \n");
        return;
}

# Caller NAT detection
route[NATDETECT] {
    xlog("L_INFO", "$ci|log|--start NATDETECT process--\n");
#!ifdef WITH_NAT
        force_rport();
        if (nat_uac_test("19")) {
        xlog("L_INFO", "$ci|log|----uac NAT test 19 true\n");
                if (is_method("REGISTER")) {
            xlog("L_INFO", "$ci|log|----Method REGISTER -> fix nat\n");
                        fix_nated_register();
                } else {
                        if(is_first_hop()) {
                xlog("L_INFO", "$ci|log|----First hop - set contact alias\n");
                                set_contact_alias();
                        }
                }
        xlog("L_INFO", "$ci|log|----Set flag NATS\n");
                setflag(FLT_NATS);
        }
    if (nat_uac_test("3")) {
            fix_nated_contact();
            xlog("L_INFO", "$ci|log|----Rewrites the Contact header to request source ip:port\n");
    }
#!endif
    xlog("L_INFO", "$ci|log| return \n");
    return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
    xlog("L_INFO", "$ci|log|--NATMANAGE--\n");
#!ifdef WITH_NAT
        if (is_request()) {
                if(has_totag()) {
            xlog("L_INFO", "$ci|log|----SIP Request - to-tag found--\n");
                        if(check_route_param("nat=yes")) {
                                setbflag(FLB_NATB);
                xlog("L_INFO", "$ci|log|----SIP Request - route param nat=yes--\n");
                        } else {
                xlog("L_INFO", "$ci|log|----SIP Request - no route param nat=yes--\n");
            }
                }
        }
        if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

        if(has_body("application/sdp") && nat_uac_test("8")) {
        xlog("L_INFO", "$ci|log|----Fix nated sdp\n");
                fix_nated_sdp("10");
        } else {
                rtpproxy_manage("cor");
        }

        if (is_request()) {
                if (!has_totag()) {
                        if(t_is_branch_route()) {
                                add_rr_param(";nat=yes");
                xlog("L_INFO", "$ci|log|----SIP Request - to-tag not found - Branch route--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
                        }
                }
        }
        if (is_reply()) {
                if(isbflagset(FLB_NATB)) {
                        if(is_first_hop())
                                set_contact_alias();
                xlog("L_INFO", "$ci|log|----SIP Reply - FLB_NATB set - First hop--\n");
                xlog("L_INFO", "$ci|log|----add nat=yes to Record-Route header--\n");
                }
        }
#!endif
    xlog("L_INFO", "$ci|log|----Return \n");
        return;
}

# URI update for dialog requests
route[DLGURI] {
    xlog("L_INFO", "$ci|log|--DLGURI--\n");
#!ifdef WITH_NAT
        if(!isdsturiset()) {
        xlog("L_INFO", "$ci|log|--destination address URI (outbound proxy address) not set--\n");
                handle_ruri_alias();
        switch ($rc) {
        case -1:
            xlog("L_ERR", "$ci|log|--Failed to handle alias of R-URI $ru--\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            xlog("L_INFO", "$ci|log|--Alias param was found - Routing in-dialog $rm from $fu to $du--\n");
            break;
        case 2:
            xlog("L_INFO", "$ci|log|--Alias param was not found and nothing was done - Routing in-dialog $rm from $fu to $ru--\n");
            break;
         };
        }
#!endif
    xlog("L_INFO", "$ci|log| return \n");
        return;
}

# PSTN GW routing
route[PSTN] {
    xlog("L_INFO", "$ci|log|--PSTN--\n");

    xlog("L_INFO", "$ci|log|--$fu--\n");

        route(RELAY);
        exit;
        return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
        # allow XMLRPC from localhost
        if ((method=="POST" || method=="GET")
                        && (src_ip==127.0.0.1)) {
                # close connection only for xmlrpclib user agents (there is a bug in
                # xmlrpclib: it waits for EOF before interpreting the response).
                if ($hdr(User-Agent) =~ "xmlrpclib")
                        set_reply_close();
                set_reply_no_connect();
                dispatch_rpc();
                exit;
        }
        send_reply("403", "Forbidden");
        exit;
}
#!endif

#!ifdef WITH_PYFB
# FreeSWITCH routing blocks
route[FSINBOUND] {
  xlog("L_INFO", "$ci|log|--FSINBOUND--");
  if(ds_is_from_list()){
       remove_hf_re("^X-.*");
       setflag(FLAG_FROM_FS);
       xlog("L_INFO", "$ci|log|Call from FS\n");
       xlog("L_INFO", "$ci|log| return \n");
       return 1;
  }
  xlog("L_INFO", "$ci|log|Message not coming from FS\n");
  # Ã  changer si call PSTN
  xlog("L_INFO", "$ci|log| return \n");
        return -1;
}

route[FSDISPATCH] {
    xlog("L_INFO", "$ci|log|--FSDISPATCH--\n");
        if(!is_method("INVITE")){
        xlog("L_INFO", "$ci|log|Not an INVITE\n");
        xlog("L_INFO", "$ci|log| return \n");
                return;
    }

    # Get callerID
    $avp(s:callernum)=$fU;

    #Call coming from provider
    if(isflagset(FLAG_FROM_PROV)){
        xlog("L_INFO", "$ci|log|From provider - inbound script starting ... \n");
        xlog("L_INFO", "$ci|log|Number normalization starting ... \n");
        if ($rU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log|Callee strip leading + \n");
            $rU=$(rU{s.strip,1});
        }
        if ($fU=~"^\+") {
            # strip leading +
            xlog("L_INFO", "$ci|log|Caller sip_network_ip leading + \n");
            $avp(s:callernum)=$(fU{s.strip,1});
        }

        xlog("L_INFO", "$ci|log|Call type mapping starting ... \n");
        # mark type of outbound calls
        # To internal DID - mark as DID
        route(LOCATION);
        # add Header to FS
        xlog("L_INFO", "$ci|log|Add headers for FS\n");
        xlog("L_INFO", "$ci|log|X-AUTH-IP: $si\n");
        xlog("L_INFO", "$ci|log|X-AUTH-PORT: $sp\n");
        xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
        xlog("L_INFO", "$ci|log|X-PyFB-CallerNum: $avp(s:callernum)\n");
        append_hf("X-AUTH-IP: $si\r\n");
        append_hf("X-AUTH-PORT: $sp\r\n");
        append_hf("X-PyFB-DestNum: $rU\r\n");
        append_hf("X-PyFB-CallerNum: $avp(s:callernum)\r\n");

        if ($avp(s:dest)=="DID") {
            xlog("L_INFO", "$ci|log|Call type : DIDIN NUMBER \n");
            append_hf("X-PyFB-CallType: DIDIN\r\n");
            route(FSRELAY);
        } else {
            if (!registered("location")){
                exit;
            }
        }
    }

    #Call coming from FS
        if(isflagset(FLAG_FROM_FS)){
        xlog("L_INFO", "$ci|log|Message coming from FS : Routing outside - Call type : $hdr(X-PyFB-CallType)\n");
        # test type of call
        if($hdr(X-PyFB-CallType) == "DIDOUT"||$hdr(X-PyFB-CallType) == "DIDIN") {
            xlog("L_INFO", "$ci|log|Route to corresponding user \n");
            route(LOCATION);
        } else {
            xlog("L_INFO", "$ci|log|Route to PSTN \n");
            route(PSTN);
        }
        remove_hf_re("^X-");
        xlog("L_INFO", "$ci|log| return \n");
                return;
  }

  # Call coming from customer
  if(isflagset(FLAG_FROM_CUST)){
    xlog("L_INFO", "$ci|log|From customer - outbound script starting ... \n");
    xlog("L_INFO", "$ci|log|Number normalization starting ... \n");
    if ($rU=~"^\+") {
      # strip leading +
      xlog("L_INFO", "$ci|log|Callee strip leading + \n");
      $rU=$(rU{s.strip,1});
    }
    if ($fU=~"^\+") {
      # strip leading +
      xlog("L_INFO", "$ci|log|Caller strip leading + \n");
      $avp(s:callernum)=$(fU{s.strip,1});
    }
    #dialplan
    append_hf("X-PyFB-CalleeNum: $rU\r\n");
    xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallee)")) {
      xlog("L_INFO", "$ci|log|Grp callee number normalization rules found $avp(s:grpnormcallee)\n");
      xlog("L_INFO", "$ci|log|Callee Number before norm : $rU\n");
      if (!dp_translate("$avp(s:grpnormcallee)", "$rU/$rU")) {
        xlog("L_INFO", "$ci|log|No callee number normalization rules found in grp\n");
      }
      xlog("L_INFO", "$ci|log|Callee Number after norm : $rU\n");
    } else {
      xlog("L_INFO", "$ci|log|No grp callee number normalization rules found\n");
    }
    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcaller)")) {
      xlog("L_INFO", "$ci|log|Grp caller number normalization rules found $avp(s:grpnormcaller)\n");
      xlog("L_INFO", "$ci|log|Caller Number before norm : $fU\n");
      if (!dp_translate("$avp(s:grpnormcaller)", "$fU/$avp(s:callernum)")) {
        xlog("L_INFO", "$ci|log|No caller number normalization rules found in grp\n");
        # $avp(s:callernum) = $fU;
        # uac_replace_from("sip:$avp(s:callernum)@$fd");
      }
      xlog("L_INFO", "$ci|log|Caller Number after norm : $avp(s:callernum)\n");
    } else {
      xlog("L_INFO", "$ci|log|No grp caller number normalization rules found\n");
    }

    xlog("L_INFO", "$ci|log|Call type mapping starting ... \n");
    # mark type of outbound calls
    # To internal DID - mark as DID
    route(LOCATION);

    # add Header to FS
    xlog("L_INFO", "$ci|log|Add headers for FS\n");
    xlog("L_INFO", "$ci|log|X-AUTH-IP: $si\n");
    xlog("L_INFO", "$ci|log|X-AUTH-PORT: $sp\n");
    xlog("L_INFO", "$ci|log|X-PyFB-AccountId: $au\n");
    xlog("L_INFO", "$ci|log|X-PyFB-CallerNum: $avp(s:callernum)\n");
    append_hf("X-AUTH-IP: $si\r\n");
    append_hf("X-AUTH-PORT: $sp\r\n");
    append_hf("X-PyFB-DestNum: $rU\r\n");
    append_hf("X-PyFB-CallerNum: $avp(s:callernum)\r\n");

    if ($avp(s:dest)=="DID") {
      xlog("L_INFO", "$ci|log|Call type : DID NUMBER \n");
      append_hf("X-PyFB-CallType: DIDOUT\r\n");
      route(FSRELAY);
    }
    if (!dp_translate("0", "$rU/$avp(s:dest)")){
      xlog("L_INFO", "$ci|log|Invalid Destination\n");
      send_reply("420", "Invalid Destination");
      exit;
    } else {
      xlog("L_INFO", "$ci|log|s:dest value : $avp(s:dest) \n");
    }
    # To Urgency number - mak as EMERGENCY
    if ($avp(s:dest)=="EMERGENCY") {
      xlog("L_INFO", "$ci|log|Call type : EMERGENCY NUMBER \n");
      append_hf("X-PyFB-CallType: EMERGENCY\r\n");
      route(FSRELAY);
    }
    # To Own number - mark as OWN
    if ($avp(s:dest)=="OWN") {
      xlog("L_INFO", "$ci|log|Call type : OWN NUMBER \n");
      append_hf("X-PyFB-CallType: OWN\r\n");
      route(FSRELAY);
    }
    # Outbound call - mark as PSTN
    xlog("L_INFO", "$ci|log|Call type : PSTN NUMBER \n");
    append_hf("X-PyFB-CallType: PSTN\r\n");
    route(FSRELAY);
  }
  # ds_mark_dst("P");
  else {
    if (!registered("location")){
      exit;
    }
    route(FSRELAY);
  }
        #route(LOCATION);
}

route[FSRELAY] {
  xlog("L_INFO", "$ci|log|--FSRELAY--\n");

  # Call coming from provider
  if(isflagset(FLAG_FROM_PROV)){
      $avp(s:fsroute) = GROUP_SOFIA_EXT;
      #ifdef MY_IP_ADDRESS_EXTERNAL
          force_send_socket("MY_IP_ADDRESS_EXTERNAL");
      #endif
      xlog("L_INFO", "$ci|log|Route to FS profile : externe - port 5092 \n");
  } else {
      $avp(s:fsroute) = GROUP_SOFIA_INT;
      #ifdef MY_IP_ADDRESS_INTERNAL
          force_send_socket("MY_IP_ADDRESS_INTERNAL");
      #endif
      xlog("L_INFO", "$ci|log|Route to FS profile : interne - port 5090 \n");
  }

  if(!ds_select_dst($avp(s:fsroute), "4")) {
    xlog("L_INFO", "$ci|log|No FS available - end \n");
    xlog("L_INFO", "$ci|stop|----------------------------\n");
    sl_send_reply("500", "Service Unavailable");
    exit;
  }
  xlog("L_INFO", "$ci|log|List of FS available : $avp(AVP_DST)\n");
  xlog("L_INFO", "$ci|log|FS server found : relay message to $du\n");
  if($var(newbranch)==1)
  {
          append_branch();
          $var(newbranch) = 0;
  }
  xlog("L_INFO", "$ci|log| return \n");
  t_set_fr(0,1000);
  t_on_failure("RTFDISPATCH");
  route(RELAY);
  exit;
}

#!endif

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "$ci|log|--MANAGE_BRANCH--\n");
    xlog("L_INFO", "$ci|log|--new branch [$T_branch_idx] to $ru--\n");
        xdbg("new branch [$T_branch_idx] to $ru\n");
        route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "$ci|log|--MANAGE_REPLY--\n");
    xlog("L_INFO", "$ci|log|--Handling SIP response--\n");
        xdbg("incoming reply\n");
    if(status=~"18[03]") {
        xlog("L_INFO", "$ci|log|--ringing or session in progress--\n");
    }

  #!ifdef WITH_SIPTRACE
    sip_trace();
  #!endif

        if(status=~"[12][0-9][0-9]") {
                route(NATMANAGE);
        }
}

# Manage failure routing cases
failure_route[RTFDISPATCH] {
  xlog("L_INFO", "$ci|log|--RTF DISPATCH--\n");
        if (t_is_canceled()) {
                exit;
        }
        # next DST - only for 500 or local timeout
        if (t_check_status("500")
                        or (t_branch_timeout() and !t_branch_replied()))
        {
                #we mark the destination Inactive and Probing
                ds_mark_dst("tp");
                #select the new destination
                if(ds_next_dst())
                {
                        t_set_fr(0,1000);
                        xlog("L_INFO", "$ci|log|Send to next FS server : relay message to $du\n");
                        t_on_failure("RTF_DISPATCH");
                        route(RELAY);
                        exit;
                }
                else
                {
                        #last available node failed to reply, no other destination available
                        xlog("L_INFO", "$ci|log|No more FS server available : END\n");
                        send_reply("404", "No destination");
                        exit;
                }
        }
}

failure_route[MANAGE_FAILURE] {
  xlog("L_INFO", "$ci|log|--MANAGE_FAILURE--\n");
        route(NATMANAGE);

        if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
        # block call redirect based on 3xx replies.
        if (t_check_status("3[0-9][0-9]")) {
                t_reply("404","Not found");
                exit;
        }
#!endif
}

# Dispatcher detects a destination goes down
event_route[dispatcher:dst-down] {
    xlog("L_ERR", "Destination down: $rm $ru ($du)\n");
}

# Dispatcher detects a destination comes up
event_route[dispatcher:dst-up] {
    xlog("L_ERR", "Destination up: $rm $ru\n");
}
