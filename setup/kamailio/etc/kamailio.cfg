# PyFB v3.0 - file version : 2019-07-02 18:50:22

#-------------
#-------------
## 0_init.cfg

#!KAMAILIO
#
# Kamailio (OpenSER) SIP Server v5.2 - PyFreeBilling v3.0
# Author : Mathias WOLFF
# 
# config file : v3.0
#
#-- AGPL License

#-------------

#-------------
#-------------
## 1_vars.cfg

#----------------------- Custom Defined Variables ----------------------------#
#-------------------------------------

#-- IP addresses settings

#!substdef "!MY_IP_ADDRESS!1.1.1.1!g"
#!substdef "!MY_IP_ADDRESS_INTERNAL!1.1.1.2!g"
#!substdef "!MY_IP_ADDRESS_EXTERNAL!1.1.1.3!g"

#-- Domain settings

#!substdef "!SIP_FROM_DOMAIN_NAT!sip:pinger@pyfb.org!g"
#!substdef "!SIP_DOMAIN_KEEPALIVE!sip:keepalive@pyfb.org!g"

#-- DB settings

# IMPORTANT : MUST BE PRESENT IN kamailio-local.cfg !

##!define DBURL "postgres://kamailiopyfb:password@127.0.0.1:5432/kamailiopyfb"

#-- Timer settings
#!substdef "!TIMER_INVITE_NOANSWER!10000!g"

#------------- SECURITY  ----------------------------------#

#!define UABLOCKED "sundayddr|SIPScan|smap|pplsip|hamdan|Ozeki|Conaito|eyeBeam|friendly-scanner|sipvicious|sipcli|VaxSIPUserAgent" ## L594
#!define IPBANEXPIRE 300 ## L403

#!substdef "!HTABLE_AUTOEXPIRE!300!g"
##check pike param

##!define WITH_TLS


#------------- SIPCAPTURE  --------------------------------#

#!define SIPCAPTURL "sip:1.1.1.4:9060"
#!define SIPCAPT 0

#------------- Global Parameters --------------------------#

async_workers=8

#!define MULTIDOMAIN 0

#-- SIP HEADERS

server_signature = no
server_header = "Server: PyFB_v3"
user_agent_header = "PyFBv3"
sip_warning = 0


#------------ Others settings ------------------------------#
fork=yes
children=8
tcp_connection_lifetime=3605
tcp_accept_no_cl=yes
disable_tcp=no
enable_tls=false
tos=0x68
system.shutdownmode = 0 desc "System shutdown mode"

#------------- DNS settings -------------------------------#
use_dns_cache=on
dns_try_ipv6=no
dns_retr_time=1
dns_retr_no=3
dns_use_search_list=yes

#------------- Local settings -------------------------------#
include_file "kamailio-local.cfg"

#-------------

#-------------
#-------------
## 2_logging.cfg

#!ifdef WITH_DEBUG
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=4
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!else
  #-- -5:alert -4:bug -3:critical-noprefix -2:critical -1:error 0:warning 1:notice 2:info 3:debug
  debug=2
  memdbg=5
  memlog=5
  #-- Output : yes to terminal; no to syslog
  log_stderror=yes
#!endif

#-- syslog facility
log_facility=LOG_LOCAL0
log_name="pyfb"
log_prefix="{$mt $hdr(CSeq) $ci} "

#-------------

#-------------
#-------------
## 3_flags.cfg

#------------- FLAGS  -------------------------------------#

 #!define FLT_ACC 1
 #!define FLT_ACCMISSED 2
 #!define FLT_ACCFAILED 3
 #!define FLT_NATS 5
 #!define FLB_NATB 6
 #!define FLB_NATSIPPING 7
 #!define SIP_IP_OK 8
 #!define RINGING 10
 #!define CUST_AUTH_OK 11
 #!define RTPE 13
 #!define CANCELLED 14
 #!define ANSWERED 17

 #!define TRUSTED_ADR_GR_CUST 1
 # http://kamailio.org/docs/modules/4.4.x/modules/permissions.html#sec-registration-permissions
 #!define TRUSTED_ADR_GR_REG_CUST 2 # filtered to be implemented
 #!define TRUSTED_ADR_GR_GW 10
 #!define GROUP_GL_NORM_RULE 0

 #!define GROUP_OP_SERVERS 4

 flags
   FLAG_FROM_CUST: 10,
   FLAG_FROM_PROV: 11,
   FLAG_TRUSTED_SOURCE: 12;

#-------------

#-------------
#-------------
## 4_modules.cfg

#-------------------- Modules Section ----------------------------------------#

#-- modules directory

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

#-- core modules

loadmodule "kex.so"
loadmodule "corex.so"

#-------- Loading Mod postgres ------------------------------------------------#

loadmodule "db_postgres.so"

#-------- Loading Mod TLS -----------------------------------------------------#

#!ifdef WITH_TLS
  enable_tls=yes
  loadmodule "tls.so"
  modparam("tls", "config", "/etc/kamailio/tls.cfg")
#!endif

#-------- Loading Mod TM ------------------------------------------------------#

loadmodule "tm.so"
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", TIMER_INVITE_NOANSWER)
modparam("tm", "fr_inv_timer", 120000)

loadmodule "tmx.so"

#-------- Loading Mod SL ---------------------------------------------#

loadmodule "sl.so"

#-------- Loading Mod RR ---------------------------------------------#

loadmodule "rr.so"
modparam("rr", "append_fromtag", 1)
modparam("rr", "enable_full_lr", 1)

#-------- Loading Mod PV ---------------------------------------------#
loadmodule "pv.so"
modparam("pv", "varset", "defaultChannels=i:2")
modparam("pv", "varset", "max_attempts=i:2")

#-------- Loading Mod AVPOPS -----------------------------------------#
loadmodule "avpops.so"
modparam("avpops", "db_url", DBURL)
modparam("avpops", "avp_table", "usr_preferences")

#-------- Loading Mod MAXFWD -----------------------------------------#
loadmodule "maxfwd.so"

#-------- Loading Mod USRLOC -----------------------------------------#
loadmodule "usrloc.so"
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "use_domain", MULTIDOMAIN)
modparam("usrloc", "timer_interval", 20)
modparam("usrloc", "timer_procs", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)

#-------- Loading Mod ALIASDB ----------------------------------------#
loadmodule "alias_db.so"
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)

#-------- Loading Mod REGISTRAR --------------------------------------#
## usrloc and sl module must be loaded before
loadmodule "registrar.so"
modparam("registrar", "method_filtering", 1)
modparam("registrar", "append_branches", 0)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)
modparam("registrar", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod AUTH -----------------------------------------#
loadmodule "auth.so"
modparam("auth", "nonce_count", 1)
modparam("auth", "qop", "auth")
modparam("auth", "nonce_expire", 60)
modparam("auth", "nonce_auth_max_drift", 2)
modparam("auth", "auth_checks_register", 11)
modparam("auth", "auth_checks_no_dlg", 9)
modparam("auth", "auth_checks_in_dlg", 15)
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "version_table", 0)
loadmodule "permissions.so"
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
modparam("permissions", "peer_tag_avp", "$avp(s:sipacid)")

#-------- Loading Mod DISPATCHER ------------------------------------#
/* loadmodule "dispatcher.so"
#modparam("dispatcher", "db_url", DBPYFBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 1)
modparam("dispatcher", "ds_ping_latency_stats", 1)
modparam("dispatcher", "ds_latency_estimator_alpha", 900)
modparam("dispatcher", "ds_ping_from", "sip:sipcheck@MY_IP_ADDRESS")
modparam("dispatcher", "ds_ping_method", "INFO")
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_probing_threshold", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=5;class=2;code=480;code=404;code=403;code=488;class=3") */

#-------- Loading Mod DIALPLAN ---------------------------------------#
loadmodule "dialplan.so"
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "attrs_pvar", "$avp(s:dest)")

#-------- Loading Mod HTTP------------------------------#
loadmodule "http_async_client.so"
modparam("http_async_client", "curl_verbose", 1)
modparam("http_async_client", "workers", 4)
modparam("http_async_client", "hash_size", 4096)
modparam("http_async_client", "connection_timeout", 1000)

#-------- Loading Mod JSON MODULES------------------------------#
loadmodule "jansson.so"
loadmodule "rtjson.so"

#-------- Loading Mod REDIS -----------------------------------------#
loadmodule "ndb_redis.so"
modparam("ndb_redis", "server", "name=srv1;addr=127.0.0.1;port=6379;db=2")

#-------- Loading Mod DIALOG ---------------------------------------#
loadmodule "dialog.so"
modparam("dialog", "db_url", DBURL)
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "track_cseq_updates", 1)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "db_mode", 0)
modparam("dialog", "db_update_period", 45)
modparam("dialog", "profiles_with_value", "endptChannels; custChannels; didChannels;")
modparam("dialog", "profiles_no_value", "inbound ; outbound")
modparam("dialog", "dlg_flag", 4)

#-------- Loading Mod NATHELPER ------------------------------------#
## usrloc module must be loaded before
loadmodule "nathelper.so"
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "SIP_FROM_DOMAIN_NAT")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

#-------- Loading Mod RTPENGINE  ------------------------------------#
loadmodule "rtpengine.so"
modparam("rtpengine", "rtpengine_sock", RTPENGINE_LIST)
modparam("rtpengine", "mos_average_pv", "$avp(mos_average)")
modparam("rtpengine", "setid_avp", "$avp(setid)")

#-------- Loading Mod IPOPS -----------------------------------------#
loadmodule "ipops.so"

#-------- Loading Mod UAC -------------------------------------------#
## tm, rr et dialog modules must be loaded before
loadmodule "uac.so"
modparam("uac", "reg_db_table", "uacreg")
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_retry_interval", 300)
modparam("uac", "reg_contact_addr", "MY_IP_ADDRESS_EXTERNAL:5060")

#-------- Loading Mod PIKE ------------------------------------------#
#!ifdef WITH_ANTIFLOOD
  loadmodule "pike.so"
  modparam("pike", "sampling_time_unit", 2)
  modparam("pike", "reqs_density_per_unit", 16)
  modparam("pike", "remove_latency", 4)
#!endif

#-------- Loading Mod XLOG XHTTP SIPUTILS AND SANITY  ---------------#
loadmodule "textops.so"
loadmodule "sdpops.so"
## sl module must be loaded before
loadmodule "siputils.so"
loadmodule "xlog.so"
modparam("xlog", "prefix", "| ")
#modparam("xlog", "log_facility", "LOG_DAEMON1") => for production change it
loadmodule "sanity.so"

#-------- Loading Mod DEBUG -----------------------------------------#
#!ifdef WITH_DEBUG
  loadmodule "debugger.so"
  modparam("debugger", "cfgtrace", 1)
  modparam("debugger", "log_level_name", "exec")
#!endif

#-------- Loading Mod HASH TABLE -------------------------------------#
loadmodule "htable.so"
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
modparam("htable", "htable", "maliciousMap=>size=12;autoexpire=300;")
modparam("htable", "htable", "rhs=>size=32;initval=0;autoexpire=300;")

#------ Loading Mod ACC ----------------------------------------------#

loadmodule "acc.so"
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "db_url", DBURL)
modparam("acc", "cdrs_table", "pyfb_reporting_cdr")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "db_table_missed_calls", "missed_calls")
modparam("acc", "time_mode", 1)
modparam("acc", "db_extra",
        "from_user=$fU;from_domain=$fd;src_ip=$si;ruri_user=$rU;ruri_domain=$rd;cseq=$cs")
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_on_failed", 1)
modparam("acc", "cdr_start_id", "start_stamp")
modparam("acc", "cdr_end_id", "end_stamp")
modparam("acc", "cdr_duration_id", "duration")
modparam("acc", "cdr_extra",
        "aleg_uuid=$dlg_var(callid);"
        "bleg_uuid=$dlg_var(b_callid);"
        "customer_id=$dlg_var(customer_id);"
        "customer_ip=$dlg_var(cust_ip);"
        "customer_endpoint_id=$dlg_var(customer_endpoint_id);"
        "caller_number=$dlg_var(caller_number);"
        "callee_number=$dlg_var(called_number);"
        "sip_code=$rs;"
        "sip_reason=$rr;"
        "ratecard_id_id=$dlg_var(ratecard_id);"
        "rate=$dlg_var(rate);"
        "sip_user_agent=$dlg_var(ua);"
        "kamailio_server=$dlg_var(kamailio);"
        "media_server_id=$dlg_var(rtpe);"
        "sip_rtp_rxstat=$avp(mos_average);"
        "sip_rtp_txstat=$avp(mos_average);"
        "route_json=$dlg_var(route_json);"
        "direction=$dlg_var(direction)")
modparam("acc", "cdr_extra_nullable", 1)

#------ Loading Mod for stats -------------------------------------------#
loadmodule "rtimer.so"
modparam("rtimer", "timer", "name=stats;interval=300;mode=1;")
modparam("rtimer", "exec", "timer=stats;route=STATS")

loadmodule "cfgutils.so"

loadmodule "sqlops.so"
modparam("sqlops", "sqlcon", CADBURL)
# Allow Kamailio startup even if connection to db fails at start !
# modparam("sqlops", "connect_mode", 1)

#------ Loading Mod topos -------------------------------------------#

/* loadmodule "topos.so"
modparam("topos", "storage", "redis")
modparam("topos", "mask_callid", 0)
modparam("topos", "sanity_checks", 0)
modparam("topos", "branch_expire", 10800)
modparam("topos", "dialog_expire", 10800)
modparam("topos", "clean_interval", 60)

loadmodule "topos_redis.so"
modparam("topos_redis", "serverid", "srv1") */

#------ Loading Mod SIPTRACE -------------------------------------------#
#!ifdef WITH_SIPTRACE
    loadmodule "siptrace.so"
    modparam("siptrace", "duplicate_uri", SIPCAPTURL)
    modparam("siptrace", "hep_mode_on", 1)
    modparam("siptrace", "trace_to_database", 0)
    modparam("siptrace", "trace_flag", 2)
    modparam("siptrace", "hep_version", 1)
    modparam("siptrace", "trace_on", SIPCAPT)
#!endif

#-------------

#-------------
#-------------
## 5_request_route.cfg

#-- MAIN ROUTING SECTION
# -1- request route
# -2- req init
# -3- within dialog
# -4- relay
# -5- uri update for dialog request
# -6- manage branch
# -7- manage reply
# -8- manage failure
# -9- optionnaly block 3XX

request_route {

    # log the basic info regarding this call
    xlog("L_INFO", "start|\n");
    xlog("L_INFO", "===================================================\n");
    xlog("L_INFO", " New SIP message $rm with call-ID $ci \n");
    xlog("L_INFO", "---------------------------------------------------\n");
    xlog("L_INFO", " received $pr request $rm $ou\n");
    xlog("L_INFO", " source $si:$sp\n");
    xlog("L_INFO", " from $fu\n");
    xlog("L_INFO", " to $tu\n");
    xlog("L_INFO", "---------------------------------------------------\n");
    xlog("L_INFO", "---------------------------------------------------\n");

    # siptrace
    #!ifdef WITH_SIPTRACE
      sip_trace();
      setflag(22);
    #!endif

    # per request initial checks
    route(REQINIT);

    # NAT detection
    route(NATDETECT);

    # OPTION processing
    if(is_method("OPTIONS") && uri==myself) {
        sl_send_reply("200","Keepalive");
        xlog("L_INFO", " Send SIP answer 200-OK - Keepalive\n");
        xlog("L_INFO", "stop|=================================================\n");
        exit;
    }

    # CANCEL processing
    if (is_method("CANCEL")) {
        xlog("L_INFO", "  $rm from $si\n");

        if (t_check_trans()) {
            route(ACCOUNTING);
            route(RTPE);
            route(RELAY);
        }

        xlog("L_INFO", "  $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # handle retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # handle requests within SIP dialogs
    if (has_totag()) {
        route(WITHINDLG);
        exit;
    }

    ### only initial requests (no To tag)

    # Check supported methos
    if (!is_method("REGISTER|INVITE|ACK|BYE|CANCEL|INFO|UPDATE")) {
        sl_send_reply("405", "Method not allowed");
        exit;
    }

    # authentication
    route(AUTH);

    # record routing for dialog forming requests (in case they are routed)
    # - remove preloaded route headers
    remove_hf("Route");

    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # dispatch request to foreign domains
    #route(SIPOUT);

    ### requests for my local domains
    if(is_method("INVITE")) {
        $dlg_var(ua) = $ua;
        $dlg_var(callid) = $ci;
        route(AUTORIZATION);
        if(route(MSG_RECV_EXTERNAL)) {
            append_hf("P-hint: inbound\r\n");
          } else {
            append_hf("P-hint: outbound\r\n");
        }
    }

    # handle SUBSCRIBE and PUBLISH requests
    route(PRESENCE);

    # handle REGISTER request
    #!ifdef WITH_REGISTRAR
        if (is_method("REGISTER")) {
            route(REGISTRAR);
        }
    #!endif

    # Only initial INVITE request now !

    if ($rU==$null) {
        # request with no Username in RURI
        xlog("L_INFO", "stop|-------SIP 484---------------\n");
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # Manage dialog
    if (!is_known_dlg() || src_ip == myself) {
        dlg_manage();
        $dlg_var(cust_ip) = $siz;
    }
    $dlg_var(kamailio) = KAMAILIOID;


    # save callee ID
    $avp(callee) = $rU;
    # route(DISPATCH);

    # Do accounting
    route(ACCOUNTING);

    if(route(MSG_RECV_EXTERNAL)) {
        $dlg_var(direction) = "inbound";
        route(DID);
    }

    route(PSTN);

    route(RELAY);

    }

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xlog("L_INFO", "--MANAGE_BRANCH--\n");
    xlog("L_INFO", "--new branch [$T_branch_idx] to $ru--\n");
    xdbg("new branch [$T_branch_idx] to $ru\n");
    if(isflagset(FLAG_FROM_CUST)) {
        rtjson_update_branch();
    }

    # User Agent header removed and add PyFb one instead
    remove_hf("User-Agent");
    append_hf("User-Agent: PyFBv3\r\n");

    route(RTPE);
    route(NATMANAGE);
}

# Reply generic route (all replies goes through this route)
onreply_route {
    xlog("L_INFO", "-- Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    # User Agent header removed and add PyFb one instead
    remove_hf("User-Agent");
    append_hf("User-Agent: PyFBv3\r\n", "Call_ID");
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xlog("L_INFO", "--MANAGE_REPLY--\n");
    xlog("L_INFO", "--Handling SIP response--\n");
    xdbg("incoming reply\n");

    if(status=~"18[03]") {
        xlog("L_INFO", "--ringing or session in progress--\n");
    }

    if(status=~"[12][0-9][0-9]") {
        route(RTPE);
        route(NATMANAGE);
    }

    # Account missed calls if ringing
    if (is_method("INVITE") && t_check_status("180")) {
        setflag(FLT_ACCMISSED);
    }

  #!ifdef WITH_SIPTRACE
    sip_trace();
  #!endif
}


# Manage failure replies
failure_route {
    xlog("L_INFO", "-- Failure: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    # User Agent header removed and add PyFb one instead
    remove_hf("User-Agent");
    append_hf("User-Agent: PyFBv3\r\n", "Call_ID");
}

failure_route[MANAGE_FAILURE] {
    xlog("L_INFO", "--MANAGE_FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]--\n");
    route(NATMANAGE);

    if (t_is_canceled()) {
        xlog("L_INFO", "--MANAGE_FAILURE: t_is_canceled, exit here\n");
        exit;
    }

    if(isflagset(FLAG_FROM_CUST)) {
        if(rtjson_next_route()) {
            t_on_branch("MANAGE_BRANCH");
            t_on_failure("MANAGE_FAILURE");
            route(RELAY);
            exit;
        }
    }

  #!ifdef WITH_BLOCK3XX
    # block call redirect based on 3xx replies.
    if (t_check_status("3[0-9][0-9]")) {
        t_reply("404","Not found");
        exit;
    }
  #!endif
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    xlog("L_INFO", "-- Dialog starts with $ci\n");

    /* if(isbflagset(FLB_WEBSOCKETS)) {
        xlog("L_INFO", "-- Answered dialog involves websockets\n");
        $dlg_var(wss) = 'yes';
    } */
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    xlog("L_INFO", "-- Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");
}


onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';
    # User Agent header removed and add PyFb one instead
    remove_hf("User-Agent");
    append_hf("User-Agent: PyFBv3\r\n", "Call_ID");
}

#-------------

#-------------
#-------------
## 6_relay.cfg

# Wrapper for relaying requests
route[RELAY] {

    xlog("L_INFO", "--RELAY--\n");
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) {
            t_on_branch("MANAGE_BRANCH");
            $dlg_var(b_callid) = $ci;
        }
    }

    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }

    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    if (is_method("BYE")) {
        append_hf("X-RTP-Statistics: $rtpstat\r\n");
        xlogl("L_INFO", "rtpengine_manage()\n");
        rtpengine_manage();
    }

    if (!t_relay()) {
        xlog("L_INFO", "end|unable to relay message\n");
        sl_reply_error();
    } else {
        xlog("L_INFO", "pass|successfull relay $du\n");
    }

    xlog("L_INFO", "stop|----------------------------\n");
    exit;
}

#-------------

#-------------
#-------------
## 7_reqinit.cfg

# Per SIP request initial checks
route[REQINIT] {
    xlog("L_INFO", "--REQINIT--\n");

  #!ifdef WITH_ANTIFLOOD
    xlog("L_INFO", "Antiflood protection\n");
        # flood detection from same IP and traffic ban for a while
        # be sure you exclude checking trusted peers, such as pstn gateways
        # - local host excluded (e.g., loop to self)
    if(src_ip!=myself) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }

        if (!pike_check_req()) {
            xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }
    }
  #!endif

    if($ua =~ "(sundayddr|SIPScan|smap|pplsip|hamdan|Ozeki|Conaito|eyeBeam|friendly-scanner|sipvicious|sipcli|VaxSIPUserAgent)") {
        xlog("L_WARN", "end|dropping message with user-agent $ua from $si:$sp\n");
        $var(malicious) = $_s($ua::$var(aNumber)::$var(bNumber)::$si::$sel(via[1].host));
			  if ($sht(maliciousMap=>$var(malicious)) == $null) $sht(maliciousMap=>$var(malicious)) = 0;
			  $sht(maliciousMap=>$var(malicious)) = $sht(maliciousMap=>$var(malicious)) + 1;
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    if (is_method("INVITE|REGISTER")) {
        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
            xlog("L_WARN", "end|Someone from $si is doing an sql injection attack, blocking!\n");
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }

        if($(hdr(Record-Route)[0]{nameaddr.uri}) != $si and $(hdr(Record-Route)[0]{nameaddr.uri}) != $null) {
            xlog("L_WARN", "Spoofing attack detected from $si, blocking\n");
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }
    }

    # initial sanity checks -- messages with
    # max_forwards==0, or excessively long requests
    if (!maxfwd_process("50") && $retcode==-1) {
        xlog("L_WARN", "end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    # next hop is a gateway, so make no sense to
    # forward if MF is 0 (after decrement)
    if ( is_maxfwd_lt("5") ) {
        xlog("L_WARN", "end|too much hops from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    if(!sanity_check("1511", "7")) {
        xlog("L_WARN", "end|Malformed SIP message from $si:$sp\n");
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    # CVE-2018-8828
    if($(ci{s.len}) + $(hdr(CSeq){s.len}) + $(ft{s.len}) + $(sel(v.branch){s.len}) >= 254) {
        xlog("L_WARN", "end|Malformed SIP message from $si:$sp - header >=254\n");
        xlog("L_INFO", "stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }
    if($(rU{s.len}) > 32) {
        xlog("L_WARN", "end|Malformed SIP message from $si:$sp - r-URI username > 32\n");
        xlog("L_INFO", "stop|----------------------------\n");
        sl_send_reply("500", "Not accepted");
        exit;
    }

    # Check for shutdown mode:
  	if (!has_totag() && ($sel(cfg_get.system.shutdownmode) > 0)) {
  		send_reply("503", "Server shutting down");
  		exit;
  	}

    xlog("L_INFO", "No security issue detected : OK -> continue\n");
}

#-------------

#-------------
#-------------
## 8_withindlg.cfg

# Handle requests within SIP dialogs
route[WITHINDLG] {
    xlog("L_INFO", "--WITHINDLG--\n");

    # only confirmed dialog can continue - drop
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) {
        xlog("L_WARN", " UPDATE|INVITE method but dialog not confirmed yet!- drop\n");
        drop;
    }

    # If REGISTER method continue initial script
    if (is_method("REGISTER")) {
        xlog("L_INFO", " REGISTER method - return\n");
        return;
    }

    # if REFER method, it is not allowed
    if (is_method("REFER")) {
        xlog("L_ERR", " REFER method not allowed\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        xlog("L_INFO", "loose route TRUE\n");
        route(DLGURI);

        if (is_method("INVITE|UPDATE") && sdp_content() && nat_uac_test("18")) {
            route(RTPE);
        }

        if (is_method("BYE")) {
            xlog("L_INFO", "Method BYE - set acc flag\n");
            route(ACCOUNTING);
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            xlog("L_INFO", "Method ACK\n");
            # User Agent header removed and add PyFb one instead
            remove_hf("User-Agent");
            append_hf("User-Agent: PyFBv3\r\n", "Call_ID");
            route(RTPE);
            route(NATMANAGE);
        } else if ( is_method("NOTIFY") ) {
            xlog("L_INFO", "Method NOTIFY\n");
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }

        xlog("L_INFO", "Message has tag - no loose route -> relay\n");
        route(RELAY);
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    if (is_method("SUBSCRIBE") && uri == myself) {
        # in-dialog subscribe requests
        route(PRESENCE);
        xlog("L_INFO", "stop|----------------------------\n");
        exit;
    }

    if ( is_method("ACK") ) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            xlog("L_INFO", "stop|---no loose-route, but stateful ACK\n");
            # User Agent header removed and add PyFb one instead
            remove_hf("User-Agent");
            append_hf("User-Agent: PyFBv3\r\n", "Call_ID");
            route(RELAY);
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            xlog("L_INFO", "stop|---ACK without matching transaction ... ignore and discard\n");
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }
    }

    if ( is_method("INVITE") ) {
        sl_send_reply("100","Your Re-INVITE is received");


        if (!t_relay()) {
            sl_reply_error();
            break;
        }

        # sl_send_reply("200","OK");
        exit;
    }


    xlog("L_INFO", "stop|----------------------------\n");
    send_reply("404","Not here");
    exit;
}

#-------------

#-------------
#-------------
## 9_dlguri.cfg

# URI update for dialog requests
route[DLGURI] {
    xlog("L_INFO", "--DLGURI--\n");

    if(!isdsturiset()) {
        xlog("L_INFO", "--destination address URI (outbound proxy address) not set--\n");
        handle_ruri_alias();
        switch ($rc) {
        case -1:
            xlog("L_ERR", "--Failed to handle alias of R-URI $ru--\n");
            send_reply("400", "Bad request");
            exit;
        case 1:
            xlog("L_INFO", "--Alias param was found - Routing in-dialog $rm from $fu to $du--\n");
            break;
        case 2:
            xlog("L_INFO", "--Alias param was not found and nothing was done - Routing in-dialog $rm from $fu to $ru--\n");
            break;
        };
    }

    xlog("L_INFO", " return \n");
    return;
}

#-------------

#-------------
#-------------
## 10_registrar.cfg

# Handle SIP registrations
route[REGISTRAR] {
    xlog("L_INFO", "--REGISTRAR--\n");
    if (!is_method("REGISTER")) {
        xlog("L_INFO", "Not a REGISTER method\n");
        xlog("L_INFO", " return\n");
        return;
    }

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        #!ifdef WITH_NATSIPPING
           # do SIP NAT pinging
           setbflag(FLB_NATSIPPING);
        #!endif
    }

    xlog("L_INFO", "Save user in location DB\n");
    if (!save("location")) {
        sl_reply_error();
    }

    xlog("L_INFO", "stop|----------------------------\n");
    exit;
}

event_route[usrloc:contact-expired] {
  xlog("L_INFO", "expired contact for $ulc(exp=>aor)\n");
}

#-------------

#-------------
#-------------
## 11_location.cfg

# User location service
route[LOCATION] {
  xlog("L_INFO", "--LOCATION--\n");
  $var(DID) = $rU;

  # search in DB-based aliases
  xlog("L_INFO", "Check if DestNum is DID list \n");

  if(alias_db_lookup("dbaliases", "d")) {
    xlog("L_INFO", "DID found in dbaliases.  R-URI=$ru\n");
    $avp(s:dest)="DID";
    append_hf("P-hint: DID routing\r\n");
  }
  else  {
    xlog("L_INFO", "R-URI=$ru  DID Not found in dbaliases\n");
    return;
  }

  xlog("L_INFO", "Check if corresponding user is registred\n");

  if (!lookup("location")) {
    $var(rc) = $rc;
    #route(TOVOICEMAIL);
    t_newtran();
    switch ($var(rc)) {
    case -1:
      xlog("L_INFO","R-URI=$ru - no contact found in location DB - continue \n");
      send_reply("480", "Temporarily Unavailable");
    case -3:
      xlog("L_INFO","R-URI=$ru - internal error when searching in location DB - 404 \n");
      send_reply("404", "Not Found");
      exit;
    case -2:
      xlog("L_INFO","R-URI=$ru - contacts found, but method not support in location DB - 405 \n");
      send_reply("405", "Method Not Allowed");
      exit;
    }
  } else {
    # User is registered. Overwrite the username part of the R-URI with the DID
    $rU = $var(DID);

    if($hdr(X-PyFB-CallType) == "DIDIN" || $hdr(X-PyFB-CallType) == "DIDOUT") {
      # Numbers normalization
      $var(sipaccount) = $hdr(X-PyFB-SIPAccountId);
      xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
      # Callee normalization
      if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcalleein)")) {
        xlog("L_INFO", "Grp callee number normalization rules found $avp(s:grpnormcalleein)\n");
        xlog("L_INFO", "Callee Number before norm : $rU\n");
        if (!dp_translate("$avp(s:grpnormcalleein)", "$rU/$rU")) {
          xlog("L_INFO", "No callee number normalization rules found in grp\n");
        }
        else {
          # To field is not auto updated - do it now
          uac_replace_to("sip:$rU@$rd");
        }

        xlog("L_INFO", "Callee Number after norm : $rU\n");
      } else {
        xlog("L_INFO", "No grp callee number normalization rules found\n");
      }

      # Caller normalization
      if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallerin)")) {
        xlog("L_INFO", "Grp caller number normalization rules found $avp(s:grpnormcallerin)\n");
        xlog("L_INFO", "Caller Number before norm : $fU\n");
        if (!dp_translate("$avp(s:grpnormcallerin)", "$fU/$avp(s:callernum)")) {
          xlog("L_INFO", "No caller number normalization rules found in grp\n");
        } else {
          uac_replace_from("$avp(s:callernum)", "sip:$avp(s:callernum)@$fd");
          remove_hf("P-Asserted-Identity");
          append_hf("P-Asserted-Identity: <sip:$avp(s:callernum)@$fd>\r\n");
        }
        xlog("L_INFO", "Caller Number after norm : $avp(s:callernum)\n");
      } else {
        xlog("L_INFO", "No grp caller number normalization rules found\n");
      }
    }

    append_hf("X-PyFB-DestDIDNum: $var(DID)\r\n");
    xlog("L_INFO","R-URI=$ru  Location=$du - contact found in location DB - route to user \n");
    xlog("L_INFO"," return \n");
    return;
  }

  # when routing via usrloc, log the missed calls also
  if (is_method("INVITE")) {
    # ToDo changed to route(ACCOUNTING)
    setflag(FLT_ACCFAILED); # -- this is added to record failed calls
    setflag(FLT_ACCMISSED);
  }

  # via FS
  #route(RELAY);
        #exit;
}

#-------------

#-------------
#-------------
## 12_presence.cfg

# Presence server processing
route[PRESENCE] {
        xlog("L_INFO", "--PRESENCE--\n");
        if(!is_method("PUBLISH|SUBSCRIBE")) return;
        xlog("L_INFO", " Event: $hdr(Event)\n");

        if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
                # returns here if no voicemail server is configured
                xlog("L_INFO", "stop| 404 - No voicemail service\n");
                sl_send_reply("404", "No voicemail service");
                exit;
        }

#!ifdef WITH_PRESENCE
        if (!t_newtran()) {
                sl_reply_error();
                exit;
        }

        if(is_method("PUBLISH")) {
                handle_publish();
                t_release();
        } else if(is_method("SUBSCRIBE")) {
                handle_subscribe();
                t_release();
        }
        exit;
#!endif

        # if presence enabled, this part will not be executed
        if(is_method("SUBSCRIBE") && $hdr(Event)=="presence.winfo") {
                xlog("L_INFO", "stop| 489 - No presence service\n");
                sl_send_reply("489", "No presence service");
                exit;
        }

        if (is_method("PUBLISH") || $rU==$null) {
                xlog("L_INFO", "stop| 404 - Not here\n");
                sl_send_reply("404", "Not here");
                exit;
        }
        xlog("L_INFO", " return \n");
        return;
}

#-------------

#-------------
#-------------
## 14_auth.cfg

# Authorization and authentication
# First determine the origini of the call based on IP address :
# 1- from customer
# 2- from provider IP Auth
# 3- From provider - registred gateway
# 4- from customer et REGISTER message
#
# The second step is to determine is the sip user is registred (Not for the POC)
route[AUTH] {
    xlog("L_INFO", "--AUTH-\n");
    xlog("L_INFO", " Starting auth process ...\n");

    xlog("L_INFO", "IP Auth process ...\n");

    # 1- message fom customer
    xlog("L_INFO", "IP Auth customer ...\n");
    if(route(MSG_RECV_INTERNAL)) {
        if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_CUST)) {
            xlog("L_INFO", "Set flag FLAG_FROM_CUSTOMER\n");
            setflag(FLAG_FROM_CUST);
            $var(sipaccount) = $avp(s:sipacid);
            append_hf("X-PyFB-AccountId: $avp(s:sipacid)\r\n");
            xlog("L_INFO", "Call from customer : Source IP allowed - sipaccount : $avp(s:sipacid)\n"); # source IP allowed
            xlog("L_INFO", " return \n");
            return;
        }
    }

    # 2- message from provider
    xlog("L_INFO", "IP Auth provider ...\n");
    if(route(MSG_RECV_EXTERNAL)) {
        if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_GW)) {
            xlog("L_INFO", "Set flag FLAG_FROM_PROVIDER\n");
            setflag(FLAG_FROM_PROV);
            xlog("L_INFO", "Call from provider GW : Source IP allowed\n"); # source IP allowed
            xlog("L_INFO", " return \n");
            return;
        }
    }

    # 3- message from a registred gateway
    xlog("L_INFO", "Credential Auth provider ...\n");
    if(route(MSG_RECV_EXTERNAL)) {
        if((!is_method("REGISTER")) && uac_reg_lookup("$rU", "$ru")) {
            xlog("L_INFO", "Set flag FLAG_FROM_PROVIDER\n");
            setflag(FLAG_FROM_PROV);
            xlog("L_INFO", " request from a remote SIP provider [$rU => $tU]\n");
            ## si URI not DID : $tU in $rU
            $rU = $tU;
            xlog("L_INFO", " request from a remote SIP provider [$rU => $tU]\n");
            xlog("L_INFO", " return \n");
            return;
        }
    }

    # 4- check credential auth
    xlog("L_INFO", "Credential Auth customer ...\n");
    if(route(MSG_RECV_INTERNAL) && (is_method("REGISTER") || uri==myself)) {
        # authenticate requests
        if (!auth_check("$fd", "subscriber", "3")) {
            switch ($retcode) {
                case -1:
                    xlog("L_WARN", "auth failed - code -1 generic error - src ip: $si\n");
                    t_reply("403", "Forbidden");
                    exit;
                case -2:
                    xlog("L_WARN", "auth failed - code -2 invalid password - src ip: $si\n");
                    t_reply("500", "Internal Server Error");
                    exit;
                case -3:
                    xlog("L_WARN", "auth failed - code -3 invalid user - src ip: $si\n");
                    sl_send_reply("400", "Bad Request");
                    exit;
                case -4:
                    xlog("L_WARN", "auth failed - code -4 nonce exprired - src ip: $si\n");
                    break;
                case -5:
                    xlog("L_WARN", "auth failed - code -5 no credentials - src ip: $si\n");
                    break;
                case -6:
                    xlog("L_WARN", "auth failed - code -6 nonce reused - src ip: $si\n");
                    break;
                case -8:
                    xlog("L_WARN", "auth failed - code -8 authuser mismatch - src ip: $si\n");
                    break;
            }

            xlog("L_INFO", "Send auth challenge\n");

            # challenges for authentication by sending 401 for REGISTER and 407 for the other SIP requests
            auth_challenge("$fd", "1");
            xlog("L_INFO", "stop|----------------------------\n");
            exit;
        }

        xlog("L_INFO", "Set flag FLAG_FROM_CUSTOMER\n");
        setflag(FLAG_FROM_CUST);
        xlog("L_INFO", "User authenticated\n");
        # user authenticated - remove auth header

        if(!is_method("REGISTER|PUBLISH")){
            xlog("L_INFO", "User authenticated - not method REGISTER|PUBLISH\n");
            xlog("L_INFO", "User authenticated - remove auth header\n");
            xlog("L_INFO", "X-PyFB-AccountId: $au\n");
            $var(sipaccount) = "" + $au; # force the var to be a string
            append_hf("X-PyFB-AccountId: $au\r\n");
            consume_credentials();
        }
        return;
    }


    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        xlog("L_INFO", " Message for another relay -> not allowed - END 403\n");
        xlog("L_INFO", "stop|----------------------------\n");
        sl_send_reply("403","Not relaying");
        exit;
    }

    xlog("L_WARN", " Auth failed \n");
    exit;
}

# Get customer and endpoint infos to check authorization
route[AUTORIZATION] {
    # Only calls from customer for now
    if(isflagset(FLAG_FROM_PROV)) {
        # xlog("L_INFO", "From provider : Drop\n");
        # sl_send_reply("404","Not implemented yet");
        return;
    }

    if (sql_xquery("ca", "SELECT e.id AS customer_endpoint_id, e.max_calls AS e_max_calls, e.calls_per_second AS e_cps, outbound_caller_id_name, outbound_caller_id_number, force_caller_id, masq_caller_id, pai, pid, ppi, transcoding_allowed, recording_allowed, recording_always, customer_id, cli_debug, CAST((credit_limit * 1000000) AS INTEGER) AS credit_limit, c.max_calls AS c_max_calls, c.calls_per_second AS c_cps, customer_enabled, CAST((customer_balance * 1000000) AS INTEGER) AS balance FROM pyfb_endpoint_customer e JOIN pyfb_customer c ON c.id = e.customer_id JOIN pyfb_company co ON co.id = c.company_id WHERE e.name = $(var(sipaccount){sql.val.str}) ;", "ra") == 1 )
    {
        // customer_enabled, company_id, customer_balance
        $dlg_var(customer_endpoint_id) = $xavp(ra=>customer_endpoint_id);
        xlog("L_INFO", "customer endpoint id : $dlg_var(customer_endpoint_id)\n");
        $dlg_var(customer_id) = $xavp(ra=>customer_id);
        xlog("L_INFO", "customer id : $dlg_var(customer_id)\n");
        $var(customer_enabled) = $xavp(ra=>customer_enabled);
        xlog("L_INFO", "Is customer enabled ? : $var(customer_enabled)\n");
        // If customer is disabled, end of call
        if ($var(customer_enabled) == 0) {
            pv_unset("$xavp(ra)");
            xlog("L_WARN", " customer account disabled - END 403\n");
            xlog("L_INFO", "stop|----------------------------\n");
            sl_send_reply("403","Authorization failed - customer account disabled");
            exit;
        }
        $var(credit_limit) = $xavp(ra=>credit_limit);
        xlog("L_INFO", "customer credit limit : $var(credit_limit)\n");
        $var(balance) = $xavp(ra=>balance);
        xlog("L_INFO", "customer balance : $var(balance)\n");
        // If balance < credit_limit, end of call
        if ($var(balance) < $var(credit_limit) && route(MSG_RECV_INTERNAL)) {
            pv_unset("$xavp(ra)");
            xlog("L_WARN", " customer balance < credit limit - END 403\n");
            xlog("L_INFO", "stop|----------------------------\n");
            sl_send_reply("402","Authorization failed - low balance");
            exit;
        }
        $var(c_max_calls) = $xavp(ra=>c_max_calls);
        xlog("L_INFO", "customer max calls limit : $var(c_max_calls)\n");
        $var(c_cps) = $xavp(ra=>c_cps);
        xlog("L_INFO", "customer max calls limit : $var(c_cps)\n");
        $var(e_max_calls) = $xavp(ra=>e_max_calls);
        xlog("L_INFO", "endpoint max calls limit : $var(e_max_calls)\n");
        $var(e_cps) = $xavp(ra=>e_cps);
        xlog("L_INFO", "endpoint max calls limit : $var(e_cps)\n");

        route(LIMIT_CALLS);

        $var(outbound_caller_id_name) = $xavp(ra=>outbound_caller_id_name);
        xlog("L_INFO", "outbound_caller_id_name : $var(outbound_caller_id_name)\n");
        $var(outbound_caller_id_number) = $xavp(ra=>outbound_caller_id_number);
        xlog("L_INFO", "outbound_caller_id_number : $var(outbound_caller_id_number)\n");
        $var(force_caller_id) = $xavp(ra=>force_caller_id);
        xlog("L_INFO", "force_caller_id : $var(force_caller_id)\n");
        $var(masq_caller_id) = $xavp(ra=>masq_caller_id);
        xlog("L_INFO", "masq_caller_id : $var(masq_caller_id)\n");
        $var(pai) = $xavp(ra=>pai);
        xlog("L_INFO", "add PAI ? : $var(pai)\n");
        $var(ppi) = $xavp(ra=>ppi);
        xlog("L_INFO", "add PPI ? : $var(ppi)\n");
        $var(pid) = $xavp(ra=>pid);
        xlog("L_INFO", "add PID ? : $var(pid)\n");
        $var(transcoding_allowed) = $xavp(ra=>transcoding_allowed);
        xlog("L_INFO", "transcoding_allowed : $var(transcoding_allowed)\n");
        $var(recording_allowed) = $xavp(ra=>recording_allowed);
        xlog("L_INFO", "recording_allowed : $var(recording_allowed)\n");
        $var(recording_always) = $xavp(ra=>recording_always);
        xlog("L_INFO", "recording_always : $var(recording_always)\n");


        pv_unset("$xavp(ra)");
        return;
    } else {
        pv_unset("$xavp(ra)");
        sl_send_reply("403","Authorization failed");
        exit;
    }
}

#-------------

#-------------
#-------------
## 15_nat.cfg

# Caller NAT detection
route[NATDETECT] {
    xlog("L_INFO", "--start NATDETECT process--\n");
    force_rport();

    if (nat_uac_test("19")) {
        xlog("L_INFO", "----uac NAT test 19 true\n");

        if (is_method("REGISTER")) {
            xlog("L_INFO", "----Method REGISTER -> fix nat\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                xlog("L_INFO", "----First hop - set contact alias\n");
                set_contact_alias();
            }
        }

        xlog("L_INFO", "----Set flag NATS\n");
        setflag(FLT_NATS);
    }

    xlog("L_INFO", " return \n");
    return;
}

route[NATMANAGE] {
    xlog("L_INFO", "--NATMANAGE--\n");

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header initiated by us
    if (is_request() && has_totag()) {
        xlog("L_INFO", "----SIP Request - to-tag found--\n");
        if(check_route_param("nat=yes")) {
            setbflag(FLB_NATB);
            xlog("L_INFO", "----SIP Request - route param nat=yes--\n");
        } else {
            xlog("L_INFO", "----SIP Request - no route param nat=yes--\n");
        }
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

/*     # Fix sdp if UA behind NAT
    if(has_body("application/sdp") && nat_uac_test("8")) {
        xlog("L_INFO", "----Fix nated sdp\n");
        fix_nated_sdp("10");
    } */

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        add_rr_param(";nat=yes");
        xlog("L_INFO", "----SIP Request - to-tag not found - Branch route--\n");
        xlog("L_INFO", "----add nat=yes to Record-Route header--\n");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        set_contact_alias();
        xlog("L_INFO", "----SIP Reply - FLB_NATB set - First hop--\n");
        xlog("L_INFO", "----add nat=yes to Record-Route header--\n");
    }

    xlog("L_INFO", "----Return \n");
    return;
}

#-------------

#-------------
#-------------
## 16_pstn.cfg

# PSTN GW routing
route[PSTN] {
    xlog("L_INFO", "--PSTN--\n");
    # Only calls from customer
    if(isflagset(FLAG_FROM_PROV)) {
        xlog("L_INFO", "From provider : Drop\n");
        sl_send_reply("404","Not implemented yet");
        exit;
    }

    # Clean CallerID and related headers
    route(REMOVEPLUS);
    route(REMOVEPAI);
    route(REMOVERPID);

    # Normalize Callee and Caller numbers
    route(NORMALIZATION);

    # Set dialog vars
    //$dlg_var(customer_id) = '1'; #$var(sipaccount); #'1';
    $dlg_var(caller_number) = $avp(s:callernum);
    $dlg_var(called_number) = $rU;
    $dlg_var(direction) = "outbound";
    $dlg_var(rtpe) = $avp(setid);

    # Set privacy
    #ToDo

    # Get outbound route
    route(PSTN_GET_ROUTE);

}

route[PSTN_GET_ROUTE] {
    xlog("L_INFO", "--PSTN_GET_ROUTE--\n");

    # create a transaction to be paused, and resumed in route[HTTP_REPLY]
    t_newtran();

    # Get routes informations
    xlog("L_INFO", "Async query to API4 : outboundroutes\n");
    http_async_query("http://MY_ROUTER_ADDRESS:MY_ROUTER_PORT/v1/outboundroute?socket=MY_IP_ADDRESS_EXTERNAL&r_uri=$dlg_var(called_number)&f_uri=$dlg_var(caller_number)&customer_id=$dlg_var(customer_id)", "PSTN_HTTP_REPLY");

}

route[PSTN_HTTP_REPLY] {
    if ($http_ok) {
        xlog("L_INFO", "route[HTTP_REPLY]: status $http_rs\n");
        xlog("L_INFO", "route[HTTP_REPLY]: body   $http_rb\n");
    } else {
        xlog("L_INFO", "route[HTTP_REPLY]: error  $http_err)\n");
    }

    //Get all response for cdr
    jansson_get("", $http_rb, "$dlg_var(route_json)");
    jansson_get("[0]", $http_rb, "$var(route_json)");
    xlog("L_INFO", "route_json : $var(route_json)--\n");

    // Get ratecard_id - as integer, need to use and intermediate var
    jansson_get("rate.ratecard_id", $http_rb, "$var(ratecard_id)");
    $dlg_var(ratecard_id) = $var(ratecard_id);
    xlog("L_INFO", "ratecard_id : $dlg_var(ratecard_id)--\n");
    jansson_get("rate.rate", $http_rb, "$var(rate)");
    $dlg_var(rate) = $var(rate);
    jansson_get("rate.block_min_duration", $http_rb, "$var(block_min_duration)");
    $dlg_var(block_min_duration) = $var(block_min_duration);
    jansson_get("rate.minimal_time", $http_rb, "$var(minimal_time)");
    $dlg_var(minimal_time) = $var(minimal_time);
    jansson_get("rate.init_block", $http_rb, "$var(init_block)");
    $dlg_var(init_block) = $var(init_block);

    rtjson_init_routes("$http_rb");
    rtjson_push_routes();
    t_on_branch("MANAGE_BRANCH");
    t_on_failure("MANAGE_FAILURE");
    route(RELAY);
    exit;
}

#-------------

#-------------
#-------------
## 17_normalization.cfg

route[REMOVEPLUS] {
    xlog("L_INFO", "--REMOVEPLUS--\n");

    if ($rU=~"^\+") {
        # strip leading +
        xlog("L_INFO", "Callee strip leading + \n");
        $rU=$(rU{s.strip,1});
        xlog("L_INFO", "Callee : $rU \n");
    }

    $avp(s:callernum)=$fU;
    if ($fU=~"^\+") {
        # strip leading +
        xlog("L_INFO", "Caller leading + \n");
        $avp(s:callernum)=$(fU{s.strip,1});
    }
}

# Get and remove PAI
route[REMOVEPAI] {
    xlog("L_INFO", "--REMOVEPAI--\n");

    if (is_present_hf("P-Asserted-Identity")) {
        xlog("L_INFO", " PAI detected\n");
        $avp(s:paicallernum)=$(hdr(P-Asserted-Identity){tobody.user});
        if ($avp(s:paicallernum)=~"^\+") {
            # strip leading +
            xlog("L_INFO", "Caller leading + \n");
            $avp(s:paicallernum)=$(avp(s:paicallernum){s.strip,1});
        }
        xlog("L_INFO", " Retrieved CallerId ($avp(s:paicallernum)) from P-Asserted-Identity header \r\n");
        xlog("L_INFO", " Remove PAI header \n");
        remove_hf("P-Asserted-Identity");

        $avp(s:callernum)=$avp(s:paicallernum);
    }
}

# Get and remove PPI
route[REMOVEPPI] {
    xlog("L_INFO", "--REMOVEPPI--\n");

    if (is_present_hf("P-Prefered-Identity")) {
        xlog("L_INFO", " PPI detected\n");
        $avp(s:ppicallernum)=$(hdr(P-Prefered-Identity){tobody.user});
        if ($avp(s:ppicallernum)=~"^\+") {
            # strip leading +
            xlog("L_INFO", "Caller leading + \n");
            $avp(s:ppicallernum)=$(avp(s:ppicallernum){s.strip,1});
        }
        xlog("L_INFO", " Retrieved CallerId ($avp(s:ppicallernum)) from P-Prefered-Identity header \r\n");
        xlog("L_INFO", " Remove PPI header \n");
        remove_hf("P-Prefered-Identity");

        $avp(s:callernum)=$avp(s:ppicallernum);
    }
}

# Get and remove RPID
route[REMOVERPID] {
    xlog("L_INFO", "--REMOVEPID--\n");

    if (is_present_hf("Remote-Party-ID")) {
        xlog("L_INFO", " RPID detected\n");
        $avp(s:rpidcallernum)=$(hdr(Remote-Party-ID){tobody.user});
        xlog("L_INFO", " Retrieved CallerId ($avp(s:rpidcallernum)) from Remote-Party-ID header \r\n");
        xlog("L_INFO", " Remove RPID header \n");
        remove_hf("Remote-Party-ID");
    }

}

# Normalize Calle and Caller numbers
route[NORMALIZATION] {
    xlog("L_INFO", "--NORMALIZATION--\n");

    # Get the value to check in usr_pref
    # If it is a call from customer, we check the value associated with sipaccount number
    if(isflagset(FLAG_FROM_CUST)){
        xlog("L_INFO", "SIP Account number : $var(sipaccount)\n");
        $avp(s:avp_norm_variable)=$var(sipaccount);
    }

    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcallee)")) {
        xlog("L_INFO", "Grp callee number normalization rules found $avp(s:grpnormcallee)\n");
        xlog("L_INFO", "Callee Number before norm : $rU\n");
        if (!dp_translate("$avp(s:grpnormcallee)", "$rU/$rU")) {
            xlog("L_INFO", "No callee number normalization rules found in grp\n");
        }
        xlog("L_INFO", "Callee Number after norm : $rU\n");
    } else {
        xlog("L_INFO", "No grp callee number normalization rules found\n");
    }

    if (avp_db_load("$var(sipaccount)", "$avp(s:grpnormcaller)")) {
        xlog("L_INFO", "Grp caller number normalization rules found $avp(s:grpnormcaller)\n");
        xlog("L_INFO", "Caller Number before norm : $fU\n");
        if (!dp_translate("$avp(s:grpnormcaller)", "$fU/$avp(s:callernum)")) {
            xlog("L_INFO", "No caller number normalization rules found in grp\n");
            # $avp(s:callernum) = $fU;
            # uac_replace_from("sip:$avp(s:callernum)@$fd");
        }
        xlog("L_INFO", "Caller Number after norm : $avp(s:callernum)\n");
    } else {
        xlog("L_INFO", "No grp caller number normalization rules found\n");
    }
}


#-------------

#-------------
#-------------
## 18_limit.cfg

route[LIMIT_CALLS] {
    xlog("L_INFO", "$ci|log|--LIMIT_CALLS--\n");
//endptChannels
    if (!dlg_isflagset("1")) {
        if (get_profile_size("custChannels", "$dlg_var(customer_id)", "$avp(calls)")) {
            xlog("L_INFO","CHECKLIMITS:  Currently, the customer $dlg_var(customer_id) has $avp(calls) active outgoing calls and limited to $var(c_max_calls)\n");

            if ($avp(calls) >= $var(c_max_calls)) {
                xlog("L_INFO", "Concurrent calls limit reached");
                sl_send_reply("487", "Request Terminated: Channel limit exceeded");
                setflag(FLT_ACC);
	              setflag(FLT_ACCFAILED);
                exit;
                # terminating this call will automatically remove the call from the profile
            } else {
                dlg_manage();
                dlg_setflag("1");
                $dlg_var(cust_ip) = $siz;
                $dlg_var(kamailio) = KAMAILIOID;
                set_dlg_profile("custChannels","$dlg_var(customer_id)");
            }
        }
    }

    $avp(rateHashSec) = "$dlg_var(customer_id):sec:"+$timef(%Y/%m/%d_%H_%M_%S);

    $avp(ratePerSec) = $shtinc(rhs=>$avp(rateHashSec));
    $avp(limitPerSec) = $var(c_cps);
    if ($avp(ratePerSec) > $avp(limitPerSec)) {
        xlog("L_WARN", "CPS Limit on $dlg_var(customer_id)");
        send_reply("503", "CPS Limit reached");
        exit;
    }
}

#-------------

#-------------
#-------------
## 19_did.cfg

route[DID] {
    xlog("L_INFO", "--DID--\n");

    # Only calls from provider
    if(isflagset(FLAG_FROM_CUST)) {
        xlog("L_INFO", "From customer : Drop\n");
        sl_send_reply("404","Not implemented yet");
        exit;
    }

    # Clean CallerID and related headers
    route(REMOVEPLUS);
    route(REMOVEPAI);
    route(REMOVERPID);

    # Normalize Callee and Caller numbers
    route(NORMALIZATION);

    xlog("L_INFO", "$ci|log|Call type mapping starting ... \n");
        # mark type of outbound calls
        # To internal DID - mark as DID
    route(LOCATION);

    if ($avp(s:dest)=="DID") {
            xlog("L_INFO", "$ci|log|Call type : DIDIN NUMBER \n");
            append_hf("X-PyFB-CallType: DIDIN\r\n");
            route(RELAY);
        } else {
            if (!registered("location")){
                exit;
        }
    }

}


#-------------

#-------------
#-------------
## 20_stats.cfg

route[STATS] {
    xlog("stats timer routine: time is $TF\n");
    # push stats to db 
    # kam_id force to 1 // to be changed
    sql_query("ca", "insert into statistics (kamailio_id,time_stamp,random,shm_used_size,shm_real_used_size,shm_max_used_size,shm_free_used_size,ul_users,ul_contacts) values (1,$Ts,$RANDOM,$stat(used_size),$stat(real_used_size),$stat(max_used_size),$stat(free_size),$stat(location-users),$stat(location-contacts))", "ra");
}

#-------------

#-------------
#-------------
## 21_rtpe.cfg

# Manages RTP Engine
route[RTPE] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;

    if (is_method("ACK") && !has_body("application/sdp")) return;

    $var(common_opts) = 'replace-session-connection replace-origin';

    if (nat_uac_test("18")) {
        xlog("L_INFO", "-- RTPENGINE: NAT detected, do not trust SDP addresses\n");
        $var(symmetry) = 'SIP-source-address';
    } else {
        xlog("L_INFO", "-- RTPENGINE: No NAT detected, trust SDP addresses\n");
        $var(symmetry) = 'trust-address';
    }

    if ($dlg_var(wss) == 'yes') {
        if ($proto == 'ws' || $proto == 'wss' ) {
            xlog("L_INFO", "-- RTPENGINE: Is through $proto, convert to udp\n");
            $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
        } else {
            xlog("L_INFO", "-- RTPENGINE: Is through $proto (non-ws), convert to wss\n");
            $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
        }
    } else {
        $var(wsopts) ='ICE=remove RTP/AVP';
    }

    $var(interfaces) = "";

    if(isflagset(FLAG_FROM_CUST)){
        xlog("L_INFO", "-- status [12]xxi from Customer - engage rtpengine--\n");
        $var(interfaces) = "direction=external direction=internal";
    } else {
        xlog("L_INFO", "-- status [12]xx from outside - engage rtpengine--\n");
        $var(interfaces) = "direction=internal direction=external";
    }


    /* if ($Ri == $sel(cfg_get.address.main) && $dlg_var(extra_socket) != $null) {
        $var(interfaces) = "direction=" + $sel(cfg_get.address.main) + " direction=" + $dlg_var(extra_socket);
    } */

    if (sdp_content()){
        xlog("L_INFO", "-- RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)]\n");
        if (is_method("INVITE")) {
            rtpengine_offer("$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)");
        } else {
            rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts) $var(interfaces)");
        }
    }
}

#-------------

#-------------
#-------------
## 22_accounting.cfg

# Set accounting flags and dialog vars to specify call direction and callID
route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

}

#-------------

#-------------
#-------------
## 23_msg_rcv.cfg

# Detect if message comes from internal or external interface

route[MSG_RECV_INTERNAL] {
    xlog("L_INFO", "Checking if message is on internal leg, Comparing Ri $Ri\n");
    if($Ri == "MY_IP_ADDRESS_INTERNAL") {
        xlog("L_INFO", "is internal\n");
        return 1;
    }
    return -1;
}

route[MSG_RECV_INTERNAL_SIP] {
    xlog("L_INFO", "Checking if message is on internal leg, Comparing Ri $Ri and Rp $Rp\n");
    if( ($Ri == "MY_IP_ADDRESS_INTERNAL") && ($Rp == "MY_SIP_PORT_INTERNAL")) {
        xlog("L_INFO", "is internal\n");
        return 1;
    }
    return -1;
}

route[MSG_RECV_EXTERNAL] {
    xlog("L_INFO", "Checking if message is on external leg, Comparing Ri $Ri\n");
    if($Ri == "MY_IP_ADDRESS_EXTERNAL") {
        xlog("L_INFO", "is external\n");
        return 1;
    }
    return -1;
}

route[MSG_RECV_EXTERNAL_SIP] {
    xlog("L_INFO", "Checking if message is on external leg SIP, Comparing Ri $Ri and Rp $Rp\n");
    if( ($Ri == "MY_IP_ADDRESS_EXTERNAL") && ($Rp == "MY_SIP_PORT_EXTERNAL")) {
        xlog("L_INFO", "is external\n");
        return 1;
    }
    return -1;
}

route[MSG_RECV_EXTERNAL_WSS] {
    xlog("L_INFO", "Checking if message is on external leg WSS, Comparing Ri $Ri and Rp $Rp\n");
    if( ($Ri == "MY_IP_ADDRESS_EXTERNAL") && ($Rp == "MY_WSS_PORT")) {
        xlog("L_INFO", "is external\n");
        return 1;
    }
    return -1;
}

#-------------
